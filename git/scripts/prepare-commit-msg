#!/usr/bin/env python3

# Instructions
# Install in your .git/hooks project directory
# chmod +x .git/hooks/prepare-commit-msg

import re
import subprocess
import sys
from collections import namedtuple
from functools import reduce
from typing import Callable

from fpinpy import Result
from simple_term_menu import TerminalMenu

Consider = namedtuple("Consider", "branch commit_msg")

import logging

logger = logging.getLogger(__name__)
logger.setLevel("DEBUG")


def compose(*funcs):
    return lambda x: reduce(lambda acc, f: f(acc), funcs, x)


COMMIT_TYPES = [
    "fix",
    "build",
    "docs",
    "release",
    "feat",
    "test",
    "changelog",
    "refactor",
    "chore",
]

CONSIDER_BRANCH_PREFIXES = [r"^[a-zA-Z]+-[0-9]+", "NOISSUE"]

# --------------------------------------------------------------------#
#                        Regular Expressions                         #
# --------------------------------------------------------------------#

# TODO: Not yet implemented: excluding commit msg
EXCLUDE_COMMIT_PREFIXES = ["fixup!"]
# CONSIDER_BRANCH_REGEX = r'^[a-zA-Z]+-[0-9]+' + '|^' + '|^'.join(CONSIDER_BRANCH_PREFIXES)
CONSIDER_BRANCH_REGEX = "|^".join(CONSIDER_BRANCH_PREFIXES)
CONSIDER_COMMIT_MSG_REGEX = "^" + "|^".join(EXCLUDE_COMMIT_PREFIXES)

CONSIDER_COMMIT_PREDICATE = lambda value: bool(
    re.search(CONSIDER_BRANCH_REGEX, value.branch)
) and not bool(re.search(CONSIDER_COMMIT_MSG_REGEX, value.commit_msg))


# QUALIFIED_PREFIX_REGEX = "|".join(map(lambda l: f"{l}/{TICKET_MATCH_REGEX}", CONSIDER_BRANCH_PREFIXES))


# --------------------------------------------------------------------#
#                           Safe Functions                           #
# --------------------------------------------------------------------#


def safe_regex_search_hof(pattern):
    def helper(value):
        try:
            match = re.search(pattern, value)
            if match is not None:
                return Result.success(match)
            else:
                return Result.failure(
                    f'Could not find match for pattern "{pattern}" on value "{value}". Format: <ticketid>_<target_component>_some-descriptor'
                )
        except Exception as e:
            return Result.failure(e)

    return helper


def safe_group_hof(group_idx: int):
    def inner(match: re.Match):
        try:
            m = match.group(group_idx)
            return (
                Result.success(m)
                if m is not None
                else Result.failure(
                    RuntimeError(
                        f"Could not match group index {group_idx} in match '{match}'"
                    )
                )
            )
        except IndexError as e:
            return Result.failure(
                f"Invalid group index '{group_idx}' in match '{match}': {repr(e)}"
            )

    return inner


# --------------------------------------------------------------------#
#                            Domain Logic                            #
# --------------------------------------------------------------------#

# def extract_commit_type_from_branch(branch):
#     branch_to_match = safe_regex_search_hof(f"{'|'.join(CONSIDER_BRANCH_PREFIXES)}")
#     match_to_group_match = safe_group_hof(0)
#     return Result.of(branch).flatMap(branch_to_match).flatMap(match_to_group_match)


# TODO mixes unsafe print effect with pure functions
def ask_commit_type_from_user():
    print("Which Conventional Commit Type is this?")
    return (
        Result.of(TerminalMenu(COMMIT_TYPES))
        .map(lambda terminal_menu: terminal_menu.show())
        .map(lambda idx: COMMIT_TYPES[idx])
    )


def extract_ticket_id_from_branch(branch):
    # ticketid_somescope_some-descriptor
    TICKET_MATCH_REGEX = r"^([-a-zA-Z0-9]+)_.+$"  # r'[a-zA-Z]+-[0-9]+|NOISSUE'
    branch_to_match = safe_regex_search_hof(TICKET_MATCH_REGEX)
    match_to_group_match_1 = safe_group_hof(1)
    return Result.of(branch).flatMap(branch_to_match).flatMap(match_to_group_match_1)
    # TODO provide better error than "Could not find match" on failure


def extract_scope_from_branch(branch):
    # CA-123_somescope_some-descriptor
    SCOPE_MATCH_REGEX = r"^.+_([-a-zA-Z0-9.,]+)_.+$"
    branch_to_match = safe_regex_search_hof(SCOPE_MATCH_REGEX)
    match_to_group_match = safe_group_hof(1)
    return (
        Result.of(branch)
        .flatMap(branch_to_match)
        .flatMap(match_to_group_match)
        .map(lambda scope: f"({scope})")
    )


class PreparablePredicate:
    def __init__(
        self, value, predicate: Callable, description: str = "Must match predicate"
    ):
        self.value = value
        self.predicate = predicate
        # Provides error message description of requirements.
        self.description = description

    def __call__(self):
        return self.predicate(self.value)

    def __str__(self):
        return self.description


def read_commit_msg_full(commit_msg_file):
    def read_commit_msg() -> str:
        with open(commit_msg_file, encoding="utf-8") as file:
            content = file.read()
        if len(content) > 0:
            return content
        else:
            return ""

    return read_commit_msg


# --------------------------------------------------------------------#
#                              Effects                               #
# --------------------------------------------------------------------#


def write_commit_msg_full(commit_msg_file):
    def write_commit_msg(commit_msg):
        with open(commit_msg_file, "w") as file:
            file.write(commit_msg)

    return write_commit_msg


def prepare_commit_msg(original_msg: str, branch: str) -> str:
    remove_newline = lambda msg: msg.rstrip("\n")
    ensure_trailing_period = lambda msg: msg if msg.endswith(".") else f"{msg}."
    # ensure_no_trailing_period = lambda msg: msg if not msg.endswith('.') else msg.rstrip(msg[-1])

    normalize_msg = compose(remove_newline, ensure_trailing_period)
    commit_msg_formatter = (
        lambda convention_type: lambda scope: lambda ticket_id: lambda msg: f"{convention_type}{scope}: {normalize_msg(msg)} Ref: {ticket_id}\n"
    )

    new_result = Result.of(original_msg).flatMap(
        lambda orig_msg: Result.of(branch).flatMap(
            lambda brnch: extract_ticket_id_from_branch(brnch).flatMap(
                lambda tckt_id: ask_commit_type_from_user().flatMap(
                    lambda typ: extract_scope_from_branch(brnch)
                    .orElse(
                        lambda: Result.success("")
                    )  # Bug with orElse in lib. Safely ignore Unknown type.
                    .map(lambda sco: commit_msg_formatter(typ)(sco)(tckt_id)(orig_msg))
                )
            )
        )
    )
    if new_result.isFailure():
        print(f"Keeping original message because: {new_result}")
    return new_result.getOrElse(original_msg)


def prompt_user_confirmation(orig_msg: str, prepared_msg: str) -> bool:
    divider = """==============================="""
    while True:
        isConfirmed = input(
            f"Should the commit message be automatically adjusted:\n\nOriginal message\n{divider}\n{orig_msg}\n{divider}\n\nNew prefixed commit message\n{divider}\n{prepared_msg}\n{divider}\n[yes|no]? "
        )
        if isConfirmed.lower() in ["y", "yes"]:
            return True
        elif isConfirmed.lower() in ["n", "no"]:
            return False
        else:
            print("Please enter y|yes or n|no to continue...")


# --------------------------------------------------------------------#
#                                Main                                #
# --------------------------------------------------------------------#


def main(write_commit_msg: Callable, read_commit_msg: Callable):

    branch = subprocess.run(
        ["git", "rev-parse", "--abbrev-ref", "HEAD"],
        encoding="UTF-8",
        stdout=subprocess.PIPE,
    ).stdout
    original_commit_msg = read_commit_msg()

    # Change me according to your conventions
    # TODO possible change to include original commit message in predicate so that it can influence decision e.g. fixup commits
    # This decision can also be made down the line during the prepare msg step.
    is_preparable = PreparablePredicate(
        Consider(branch, original_commit_msg),
        CONSIDER_COMMIT_PREDICATE,
        f"Applies only when branch name starts with {CONSIDER_BRANCH_REGEX} and commit message does not start with {CONSIDER_COMMIT_MSG_REGEX}",
    )
    if not is_preparable():
        print(f"Skipping prepare-commit-msg because: {is_preparable}")
        return

    new_msg = prepare_commit_msg(original_commit_msg, branch)
    # if (original_commit_msg != new_msg):
    isConfirmed = prompt_user_confirmation(original_commit_msg, new_msg)

    if isConfirmed:
        write_commit_msg(new_msg)
    else:
        exit()


if __name__ == "__main__":
    # Git hook processes are not connected to fd 0
    sys.stdin = open("/dev/tty", "r")
    COMMIT_MSG_FILE = sys.argv[1]

    write_commit_msg_func = write_commit_msg_full(COMMIT_MSG_FILE)
    read_commit_msg_func = read_commit_msg_full(COMMIT_MSG_FILE)
    main(write_commit_msg_func, read_commit_msg_func)
